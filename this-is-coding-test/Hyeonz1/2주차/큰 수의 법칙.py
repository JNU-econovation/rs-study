# 주어진 수를 M번 더하되, 동일한 인덱스는 K번을 초과하여 더해질 수 없다.
# 조건 : 배열 크기 N, 더해지는 횟수 M, 동일한 인덱스를 연속하여 더할 수 있는 수 K

# 입력
n, m, k = map(int, input().split())

arr = list(map(int, input().split()))

# 1. 더해지는 형태 파악 : 배열 안의 가장 큰 수가 k번 더해지고, 두 번째로 큰 수가 1번 더해지는 작업을 반복 수행
# 2. 작업이 끝나는 시점을 파악 : 
    # 1. 배열 안의 수 중 가장 큰 수를 K번 더한다. 
    # 2. k == m일 때 끝낸다.
    # 3. k != m일 때, 배열에서 두 번째로 큰 수를 1번 더한다.
    # 4. k + 1 == m일 때 끝낸다.
    # 5. k + 2 == m? k + 3 == m? k와 m의 관계에 따라 종료 시점이 달라진다.

# m을 k에 대한 식으로 나타내야 한다. 
# => m // k 번만큼 배열 안의 가장 큰 수를 더하고 
# m % k번만큼 배열에서 두 번째로 작은 수를 1번 더한다.
# m과 k가 각각 9 3으로 주어진 경우 문제 발생

# m // k + 1 번만큼 배열에서 가장 큰 숫자를 k번, 두 번째로 큰 숫자를 1번 더한다.
# m % (k + 1)번만큼 배열에서 두번째로 큰 숫자를 더한다.

# 배열에서 가장 큰 수와 두 번째로 큰 수를 찾아야 한다.
# 다른 인덱스의 같은 수가 있는 경우의 처리
    # => 리스트.sort(reverse=True) : 리스트를 내림차순으로 정렬할 수 있다.

arr.sort(reverse=True)

if (m == k):

    print(arr[0] * k)

else:
    
    quo = m // (k + 1)
    rem = m % (k + 1)

    result = quo * k * arr[0] + quo * arr[1] + rem * k

    print(result)